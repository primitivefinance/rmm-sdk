## API Report File for "@primitivefi/rmm-sdk"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { BigNumber } from '@ethersproject/bignumber';
import { BigNumber as BigNumber_2 } from 'ethers';
import { Calibration as Calibration_2 } from 'src/entities/calibration';
import { Engine as Engine_2 } from 'src/entities/engine';
import { FixedPointX64 } from 'web3-units';
import { Interface } from '@ethersproject/abi';
import { MethodParameters as MethodParameters_2 } from 'src/utils';
import { NativeCurrency } from '@uniswap/sdk-core';
import { Percentage } from 'web3-units';
import { PermitOptions as PermitOptions_2 } from 'src/selfPermit';
import { Pool as Pool_2 } from 'src/entities/pool';
import { SelfPermit as SelfPermit_2 } from 'src/selfPermit';
import { Time } from 'web3-units';
import { Token } from '@uniswap/sdk-core';
import { Wei } from 'web3-units';

// @public
export interface AllocateOptions extends PermitTokens, LiquidityOptions, RecipientOptions, NativeOptions, Deadline {
    // (undocumented)
    createPool?: boolean;
    // (undocumented)
    fromMargin: boolean;
    // (undocumented)
    slippageTolerance: Percentage;
}

// @public (undocumented)
export interface AllowedPermitArguments extends RSV {
    expiry: BigNumber_2;
    nonce: BigNumber_2;
}

// @public
export interface BatchTransferOptions {
    // (undocumented)
    amounts: Wei[];
    // (undocumented)
    data?: string;
    // (undocumented)
    ids: string[];
    // (undocumented)
    recipient: string;
    // (undocumented)
    sender: string;
}

// @beta
export class Calibration extends Engine implements ICalibration {
    constructor(factory: string, risky: Token, stable: Token, strike: string | BigNumber, sigma: string | BigNumber, maturity: string | BigNumber, gamma: string | BigNumber);
    readonly gamma: Percentage;
    readonly maturity: Time;
    static readonly MAX_GAMMA: number;
    static readonly MAX_SIGMA: number;
    static readonly MIN_GAMMA: number;
    static readonly MIN_SIGMA = 1;
    get poolId(): string;
    readonly sigma: Percentage;
    readonly strike: Wei;
}

// @beta
export interface CalibrationStruct {
    gamma: string;
    // Warning: (ae-unresolved-inheritdoc-reference) The @inheritDoc reference could not be resolved: No member was found with name "lastTimestamp"
    //
    // (undocumented)
    lastTimestamp: string;
    maturity: string;
    sigma: string;
    strike: string;
}

// @beta
export function computeEngineAddress(factory: string, risky: string, stable: string, contractBytecode: string): string;

// @beta
export function computePoolId(engine: string, strike: string, sigma: string, maturity: string, gamma: string): string;

// @public
export interface Deadline {
    // (undocumented)
    deadline?: BigNumber;
}

// @public
export interface DefaultOptions {
    deadline: BigNumber_2;
    inputTokenPermit?: PermitOptions;
    recipient: string;
    slippageTolerance: Percentage;
}

// @beta
export class Engine extends Token implements IEngine {
    constructor(factory: string, risky: Token, stable: Token);
    static ABI: any;
    static readonly BUFFER: number;
    static BYTECODE: string;
    readonly factory: string;
    static INTERFACE: Interface;
    involvesToken(token: Token): boolean;
    get MIN_LIQUIDITY(): number;
    static readonly MIN_LIQUIDITY_FACTOR = 6;
    static readonly PRECISION: Wei;
    readonly risky: Token;
    readonly scaleFactorRisky: Wei;
    readonly scaleFactorStable: Wei;
    readonly stable: Token;
}

// @public (undocumented)
export interface ExactInResult extends SwapResult {
    output: number;
}

// @public (undocumented)
export interface ExactOutResult extends SwapResult {
    input: number;
}

// @beta
export class Floating {
    add(adder: number | Floating): Floating;
    readonly decimals: number;
    div(divider: number | Floating): Floating;
    // (undocumented)
    divCeil(divider: number | Floating): Floating;
    downscaleInteger(value: number): number;
    static from(value: number, decimals?: number): Floating;
    static readonly HALF: Floating;
    static readonly INFINITY: BigNumber_2;
    get isInfinity(): boolean;
    get isZero(): boolean;
    mul(multiplier: number | Floating): Floating;
    mulDiv(multiplier: number | Floating, divider: number | Floating): Floating;
    get normalized(): number;
    static readonly ONE: Floating;
    get raw(): number;
    // (undocumented)
    readonly _raw: number;
    get scaled(): number;
    get scaleFactor(): number;
    sub(subtractor: number | Floating): Floating;
    toFixed(decimals: number): string;
    toString(): string;
    upscaleInteger(value: number): number;
    static readonly ZERO: Floating;
}

// @beta
export function getTokenPairSaltHash(token0: string, token1: string): string;

// @public
export interface ICalibration {
    readonly gamma: Percentage;
    readonly maturity: Time;
    poolId: string;
    readonly sigma: Percentage;
    readonly strike: Wei;
}

// @beta
export interface IEngine {
    factory: string;
    involvesToken(token: Token): boolean;
    MIN_LIQUIDITY: number;
    risky: Token;
    readonly scaleFactorRisky: Wei;
    readonly scaleFactorStable: Wei;
    stable: Token;
}

// @beta
export interface IPool {
    // @alpha
    amountIn(tokenOut: Token, amountOut: number): ExactOutResult;
    // @alpha
    amountOut(tokenIn: Token, amountIn: number): ExactInResult;
    // @alpha
    derivativeOut(tokenIn: Token, amountIn: number): number;
    expired: boolean;
    getCurrentLiquidityValue(priceOfRisky: number, priceOfStable: number): {
        valuePerLiquidity: Wei;
        values: Wei[];
    };
    inTheMoney: boolean;
    readonly invariant: FixedPointX64;
    lastTimestamp: Time;
    readonly liquidity: Wei;
    liquidityQuote(amount: Wei, sideOfPool: PoolSides): {
        delRisky: Wei;
        delStable: Wei;
        delLiquidity: Wei;
    };
    premium: number;
    referencePriceOfRisky: Wei;
    remaining: Time;
    reportedPriceOfRisky: Wei;
    readonly reserveRisky: Wei;
    readonly reserveStable: Wei;
    tau: number;
}

// @public
export function isValidGamma(gamma: string): boolean;

// @public
export function isValidMaturity(maturity: string): boolean;

// @beta
export function isValidSigma(sigma: string): boolean;

// @public
export function isValidStrike(strike: string): boolean;

// @public
export interface LiquidityOptions {
    // (undocumented)
    delLiquidity: Wei;
    // (undocumented)
    delRisky: Wei;
    // (undocumented)
    delStable: Wei;
}

// @public
export interface MarginOptions extends PermitTokens, RecipientOptions, NativeOptions {
    // (undocumented)
    amountRisky: Wei;
    // (undocumented)
    amountStable: Wei;
}

// @public
export interface MethodParameters {
    calldata: string;
    value: string;
}

// @public
export interface NativeOptions {
    // (undocumented)
    useNative?: NativeCurrency;
}

// @beta
export function normalize(wad: number, decimals: number): number;

// @beta
export function parseCalibration(factory: string, risky: {
    address: string;
    decimals: string | number;
    name?: string;
    symbol?: string;
}, stable: {
    address: string;
    decimals: string | number;
    name?: string;
    symbol?: string;
}, cal: {
    strike: string;
    sigma: string;
    maturity: string;
    gamma: string;
    lastTimestamp?: string;
}, chainId?: number): Calibration_2;

// @beta
export abstract class PeripheryManager extends SelfPermit_2 {
    // (undocumented)
    static ABI: any;
    static allocateCallParameters(pool: Pool_2, options: AllocateOptions): MethodParameters_2;
    static batchTransferFromParameters(options: BatchTransferOptions): MethodParameters_2;
    // (undocumented)
    static BYTECODE: string;
    static createCallParameters(pool: Pool_2, liquidity: Wei, options?: PermitTokens): {
        calldata: string;
        value: string;
    };
    static depositCallParameters(engine: Engine_2, options: MarginOptions): MethodParameters_2;
    static encodeCreate(pool: Pool_2, liquidity: Wei): string;
    static encodeWithdraw(engine: Engine_2, options: MarginOptions): string[];
    // (undocumented)
    static INTERFACE: Interface;
    static removeCallParameters(pool: Pool_2, options: RemoveOptions): MethodParameters_2;
    static safeTransferFromParameters(options: SafeTransferOptions): MethodParameters_2;
    static withdrawCallParameters(engine: Engine_2, options: MarginOptions): MethodParameters_2;
}

// @public
export type PermitOptions = StandardPermitArguments | AllowedPermitArguments;

// @public
export interface PermitTokens {
    permitRisky?: PermitOptions_2;
    permitStable?: PermitOptions_2;
}

// @beta
export class Pool extends Calibration {
    constructor(chainId: number, factory: string, risky: {
        address: string;
        decimals: string | number;
        name?: string;
        symbol?: string;
    }, stable: {
        address: string;
        decimals: string | number;
        name?: string;
        symbol?: string;
    }, calibration: {
        strike: string;
        sigma: string;
        maturity: string;
        gamma: string;
        lastTimestamp?: string;
    }, reserves: {
        reserveRisky: string;
        reserveStable: string;
        liquidity: string;
    }, invariant?: string, referencePriceOfRisky?: number);
    amountIn(tokenOut: Token, amountOut: number): ExactOutResult;
    amountOut(tokenIn: Token, amountIn: number): ExactInResult;
    // Warning: (ae-unresolved-inheritdoc-reference) The @inheritDoc reference could not be resolved: No member was found with name "delta"
    //
    // (undocumented)
    get delta(): number | undefined;
    derivativeOut(tokenIn: Token, amountIn: number): number;
    get expired(): boolean;
    static from(pool: PoolInterface, referencePrice?: number, chainId?: number): Pool;
    static fromReferencePrice(referencePrice: number, factory: string, risky: {
        address: string;
        decimals: string | number;
        name?: string;
        symbol?: string;
    }, stable: {
        address: string;
        decimals: string | number;
        name?: string;
        symbol?: string;
    }, calibration: {
        strike: string;
        sigma: string;
        maturity: string;
        gamma: string;
        lastTimestamp?: string;
    }, chainId?: number, liquidity?: string, invariant?: number): Pool;
    getCurrentLiquidityValue(priceOfRisky: number, priceOfStable?: number): {
        valuePerLiquidity: Wei;
        values: Wei[];
    };
    static getLiquidityQuote(amount: Wei, sideOfPool: PoolSides, reserveRisky: Wei, reserveStable: Wei, liquidity: Wei): {
        delRisky: Wei;
        delStable: Wei;
        delLiquidity: Wei;
    };
    get inTheMoney(): boolean | undefined;
    readonly invariant: FixedPointX64;
    set lastTimestamp(x: Time);
    get lastTimestamp(): Time;
    readonly liquidity: Wei;
    liquidityQuote(amount: Wei, sideOfPool: PoolSides): {
        delRisky: Wei;
        delStable: Wei;
        delLiquidity: Wei;
    };
    get premium(): number | undefined;
    set referencePriceOfRisky(x: Wei | undefined);
    get referencePriceOfRisky(): Wei | undefined;
    get remaining(): Time;
    get reportedPriceOfRisky(): Wei | undefined;
    readonly reserveRisky: Wei;
    readonly reserveStable: Wei;
    // (undocumented)
    get swapArgs(): readonly [number, number, number, number, number, number, number, number, number];
    get tau(): Time;
}

// @beta
export interface PoolInterface {
    creator?: string;
    description?: string;
    image?: string;
    license?: string;
    name?: string;
    properties: {
        factory: string;
        risky: {
            address: string;
            decimals: string | number;
            symbol?: string;
            name?: string;
        };
        stable: {
            address: string;
            decimals: string | number;
            symbol?: string;
            name?: string;
        };
        invariant?: string;
        calibration: {
            strike: string;
            sigma: string;
            maturity: string;
            lastTimestamp: string;
            gamma: string;
        };
        reserve: {
            blockTimestamp?: string;
            cumulativeLiquidity?: string;
            cumulativeRisky?: string;
            cumulativeStable?: string;
            liquidity: string;
            reserveRisky: string;
            reserveStable: string;
        };
    };
    symbol?: string;
}

// @beta
export enum PoolSides {
    // (undocumented)
    RISKY = "RISKY",
    // (undocumented)
    RMM_LP = "RMM_LP",
    // (undocumented)
    STABLE = "STABLE"
}

// @public
export interface RecipientOptions {
    // (undocumented)
    recipient: string;
}

// @public
export interface RemoveOptions extends LiquidityOptions, RecipientOptions, NativeOptions, Deadline {
    // (undocumented)
    expectedRisky: Wei;
    // (undocumented)
    expectedStable: Wei;
    // (undocumented)
    slippageTolerance: Percentage;
    // (undocumented)
    toMargin: boolean;
}

// @beta
export interface ReserveStruct {
    blockTimestamp?: string;
    cumulativeLiquidity?: string;
    cumulativeRisky?: string;
    cumulativeStable?: string;
    liquidity: string;
    reserveRisky: string;
    reserveStable: string;
}

// @public
export interface RSV {
    // (undocumented)
    r: string;
    // (undocumented)
    s: string;
    // (undocumented)
    v: 0 | 1 | 27 | 28;
}

// @public
export interface SafeTransferOptions {
    // (undocumented)
    amount: Wei;
    // (undocumented)
    data?: string;
    // (undocumented)
    id: string;
    // (undocumented)
    recipient: string;
    // (undocumented)
    sender: string;
}

// @public
export abstract class SelfPermit {
    protected constructor();
    protected static encodePermit(token: Token, options: PermitOptions): string;
    // (undocumented)
    static INTERFACE: Interface;
}

// @public (undocumented)
export interface StandardPermitArguments extends RSV {
    amount: BigNumber_2;
    deadline: BigNumber_2;
}

// @beta
export abstract class SwapManager extends SelfPermit {
    // (undocumented)
    static ABI: any;
    // (undocumented)
    static BYTECODE: string;
    // (undocumented)
    static INTERFACE: Interface;
    static minimumAmountOut(slippageTolerance: Percentage, amountOut: Wei): Wei;
    static swapCallParameters(pool: Pool_2, options: SwapOptions): MethodParameters_2;
}

// @public
export interface SwapOptions extends DefaultOptions, NativeOptions {
    deltaIn: Wei;
    deltaOut: Wei;
    fromMargin: boolean;
    riskyForStable: boolean;
    toMargin: boolean;
    toRecipient?: boolean;
}

// @public
export interface SwapResult {
    invariant: number;
    priceIn: string;
}

// @public
export class Swaps {
    // @beta
    static exactRiskyInput(amountIn: number, decimalsRisky: number, decimalsStable: number, reserveRiskyFloating: number, reserveStableFloating: number, reserveLiquidityFloating: number, strikeFloating: number, sigmaFloating: number, gammaFloating: number, tauYears: number): ExactInResult;
    // @beta
    static exactRiskyOutput(amountOut: number, decimalsRisky: number, decimalsStable: number, reserveRiskyFloating: number, reserveStableFloating: number, reserveLiquidityFloating: number, strikeFloating: number, sigmaFloating: number, gammaFloating: number, tauYears: number): ExactOutResult;
    // @beta
    static exactStableInput(amountIn: number, decimalsRisky: number, decimalsStable: number, reserveRiskyFloating: number, reserveStableFloating: number, reserveLiquidityFloating: number, strikeFloating: number, sigmaFloating: number, gammaFloating: number, tauYears: number): ExactInResult;
    // @beta
    static exactStableOutput(amountOut: number, decimalsRisky: number, decimalsStable: number, reserveRiskyFloating: number, reserveStableFloating: number, reserveLiquidityFloating: number, strikeFloating: number, sigmaFloating: number, gammaFloating: number, tauYears: number): ExactOutResult;
    // @beta
    static getMarginalPriceSwapRiskyIn(reserveRiskyFloating: number, strikeFloating: number, sigmaFloating: number, tauYears: number, gammaFloating: number, amountIn: number): number;
    // @beta
    static getMarginalPriceSwapStableIn(invariantFloating: number, reserveStableFloating: number, strikeFloating: number, sigmaFloating: number, tauYears: number, gammaFloating: number, amountIn: number): number;
    static getReportedPriceOfRisky(reserveRiskyFloating: number, strikeFloating: number, sigmaFloating: number, tauYears: number): number;
    // @beta
    static getRiskyGivenStable(strikeFloating: number, sigmaFloating: number, tauYears: number, reserveStableFloating: number, invariantFloating?: number): number | undefined;
    // @beta
    static getRiskyReservesGivenReferencePrice(strikeFloating: number, sigmaFloating: number, tauYears: number, referencePriceOfRisky: number): number;
    // @beta
    static getStableGivenRisky(strikeFloating: number, sigmaFloating: number, tauYears: number, reserveRiskyFloating: number, invariantFloating?: number): number | undefined;
}

// @beta
export function validateAndParseAddress(address: string): string;

// @beta
export function validateDecimals(amount: Wei, token: Token): void;

// @beta
export function weiToWei(wei: string, decimals?: number): Wei;

// (No @packageDocumentation comment for this package)

```
